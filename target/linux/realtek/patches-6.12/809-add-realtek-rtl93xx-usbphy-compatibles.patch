--- a/Documentation/devicetree/bindings/phy/realtek,usb2phy.yaml
+++ b/Documentation/devicetree/bindings/phy/realtek,usb2phy.yaml
@@ -57,6 +57,12 @@ description: |
   XHCI controller#1 -- usb2phy -- phy#0
   XHCI controller#2 -- usb2phy -- phy#0
 
+  RTL930x/RTL931x SoCs USB
+  The USB architecture includes one OHCI, and one EHCI controller.
+  There is one USB 2.0 PHY shared between them.
+  OHCI controller -|
+  EHCI controller -+- usb2phy -- phy#0
+
 properties:
   compatible:
     enum:
@@ -69,6 +75,8 @@ properties:
       - realtek,rtd1395-usb2phy-2port
       - realtek,rtd1619-usb2phy
       - realtek,rtd1619b-usb2phy
+      - realtek,rtl930x-usb2phy
+      - realtek,rtl931x-usb2phy
 
   reg:
     items:
--- a/drivers/phy/realtek/phy-rtk-usb2.c
+++ b/drivers/phy/realtek/phy-rtk-usb2.c
@@ -194,7 +194,10 @@ static int rtk_phy_write(struct phy_reg
 	int ret = 0;
 
 	/* write data to VStatusOut2 (data output to phy) */
-	writel((u32)data << shift_bits, reg_wrap_vstatus);
+	val = readl(reg_wrap_vstatus);
+	val &= ~(PHY_REG_DATA_MASK << shift_bits);
+	val |= ((u32)data << shift_bits);
+	writel(val, reg_wrap_vstatus);
 
 	ret = utmi_wait_register(reg_gusb2phyacc0, PHY_VSTS_BUSY, 0);
 	if (ret)
@@ -975,6 +978,30 @@ static int parse_phy_data(struct rtk_phy
 		phy_parameter->phy_reg.reg_gusb2phyacc0 = of_iomap(np, 1) + index;
 		phy_parameter->phy_reg.vstatus_index = index;
 
+		// HACK, turn on reg_wrap_vstatus for reading phy register before phy initialization
+		writel(0x40000000, phy_parameter->phy_reg.reg_wrap_vstatus);
+
+		// HACK, align with vendor
+		void __iomem *phy_fm   = ioremap(0x18140210, 4); // USB_PHY_FM
+		void __iomem *ehci_cfg = ioremap(0x18140200, 4); // EHCI_EXT_CFG1
+		void __iomem *ehci_portsc = ioremap(0xb8021054, 4);;
+		if (phy_fm && ehci_cfg && ehci_portsc) {
+			writel(0x006A004A, phy_fm);     // vendor USB_PHY_FM
+			writel(0xF002CD11, ehci_cfg);   // vendor EHCI_EXT_CFG1
+			writel(0x00100000, ehci_portsc); // vendor EHCI_PORTSC
+		} else {
+			dev_err(rtk_phy->dev, "Failed to ioremap for phy_fm or ehci_cfg or ehci_portsc\n");
+		}
+
+		if (phy_fm)
+			iounmap(phy_fm);
+		if (ehci_cfg)
+			iounmap(ehci_cfg);
+		if (ehci_portsc)
+			iounmap(ehci_portsc);
+		// END HACK
+
+
 		if (of_property_read_bool(np, "realtek,inverse-hstx-sync-clock"))
 			phy_parameter->inverse_hstx_sync_clock = true;
 		else
@@ -1284,6 +1311,70 @@ static const struct phy_cfg rtd1315e_phy
 	.is_double_sensitivity_mode = true,
 };
 
+static const struct phy_cfg rtl930x_phy_cfg = {
+	.page0_size = MAX_USB_PHY_PAGE0_DATA_SIZE,
+	.page0 = {
+		[0x02] = { 0xe2, 0x3f }, /* HS bias current */
+        [0x04] = { 0xe4, 0x6c }, /* HS drive strength */
+        [0x05] = { 0xe5, 0x55 }, /* Squelch threshold */
+        [0x06] = { 0xe6, 0x03 }, /* Disconnect detect */
+        [0x07] = { 0xe7, 0x81 }, /* HS eye / pre-emphasis */
+	},
+	.page1_size = 8,
+	.page1 = {
+		[0x00] = { 0xe0, 0x21 }, /* HS chirp timing */
+        [0x01] = { 0xe1, 0x44 }, /* FS/LS edge timing */
+        [0x02] = { 0xe2, 0x18 }, /* Elastic buffer */
+        [0x03] = { 0xe3, 0x6a }, /* Clock recovery */
+	},
+	.page2_size = 0,
+	.num_phy = 1,
+	.check_efuse = true,
+	.check_efuse_version = CHECK_EFUSE_V1,
+	.efuse_dc_driving_rate = 1,
+	.dc_driving_mask = 0xf,
+	.efuse_dc_disconnect_rate = EFUS_USB_DC_DIS_RATE,
+	.dc_disconnect_mask = 0xf,
+	.usb_dc_disconnect_at_page0 = true,
+	.do_toggle = true,
+	.do_toggle_driving = false,
+	.driving_updated_for_dev_dis = 0xf,
+	.use_default_parameter = false,
+	.is_double_sensitivity_mode = false,
+};
+
+static const struct phy_cfg rtl931x_phy_cfg = {
+	.page0_size = MAX_USB_PHY_PAGE0_DATA_SIZE,
+	.page0 = {
+		[0x02] = { 0xe2, 0x37 }, /* HS bias current (↓) */
+        [0x04] = { 0xe4, 0x68 }, /* HS drive strength (↓) */
+        [0x05] = { 0xe5, 0x55 }, /* Squelch threshold */
+        [0x06] = { 0xe6, 0x03 }, /* Disconnect detect */
+        [0x07] = { 0xe7, 0x81 }, /* HS eye / pre-emphasis */
+	},
+	.page1_size = 8,
+	.page1 = {
+		[0x00] = { 0xe0, 0x23 }, /* chirp timing (Δ) */
+        [0x01] = { 0xe1, 0x44 }, /* FS/LS edge timing */
+        [0x02] = { 0xe2, 0x18 }, /* Elastic buffer */
+        [0x03] = { 0xe3, 0x6a }, /* Clock recovery */
+	},
+	.page2_size = 0,
+	.num_phy = 1,
+	.check_efuse = true,
+	.check_efuse_version = CHECK_EFUSE_V1,
+	.efuse_dc_driving_rate = 1,
+	.dc_driving_mask = 0xf,
+	.efuse_dc_disconnect_rate = EFUS_USB_DC_DIS_RATE,
+	.dc_disconnect_mask = 0xf,
+	.usb_dc_disconnect_at_page0 = true,
+	.do_toggle = true,
+	.do_toggle_driving = false,
+	.driving_updated_for_dev_dis = 0xf,
+	.use_default_parameter = false,
+	.is_double_sensitivity_mode = false,
+};
+
 static const struct of_device_id usbphy_rtk_dt_match[] = {
 	{ .compatible = "realtek,rtd1295-usb2phy", .data = &rtd1295_phy_cfg },
 	{ .compatible = "realtek,rtd1312c-usb2phy", .data = &rtd1312c_phy_cfg },
@@ -1294,6 +1385,8 @@ static const struct of_device_id usbphy_
 	{ .compatible = "realtek,rtd1395-usb2phy-2port", .data = &rtd1395_phy_cfg_2port },
 	{ .compatible = "realtek,rtd1619-usb2phy", .data = &rtd1619_phy_cfg },
 	{ .compatible = "realtek,rtd1619b-usb2phy", .data = &rtd1619b_phy_cfg },
+	{ .compatible = "realtek,rtl930x-usb2phy", .data = &rtl930x_phy_cfg },
+	{ .compatible = "realtek,rtl931x-usb2phy", .data = &rtl931x_phy_cfg },
 	{},
 };
 MODULE_DEVICE_TABLE(of, usbphy_rtk_dt_match);
--- a/drivers/phy/realtek/Kconfig
+++ b/drivers/phy/realtek/Kconfig
@@ -3,7 +3,7 @@
 # Phy drivers for Realtek platforms
 #
 
-if ARCH_REALTEK || COMPILE_TEST
+if ARCH_REALTEK || RTL930X || RTL931X || COMPILE_TEST
 
 config PHY_RTK_RTD_USB2PHY
 	tristate "Realtek RTD USB2 PHY Transceiver Driver"
